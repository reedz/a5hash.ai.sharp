using Xunit;

namespace A5Hash.Tests;

/// <summary>
/// Tests verifying C# a5hash implementation matches native C implementation.
/// These tests use vectors generated by running the native implementation.
/// </summary>
public class A5HashTests
{
    #region A5Hash (64-bit) Tests
    
    [Theory]
    [MemberData(nameof(GetTestVectors))]
    public void A5Hash_ProducesSameOutputAsNative(TestVector vector)
    {
        var hasher = new global::A5Hash.A5Hash(vector.Seed64);
        ulong actual = hasher.Hash(vector.Input);
        Assert.Equal(vector.ExpectedHash64, actual);
    }
    
    [Theory]
    [MemberData(nameof(GetLargeTestVectors))]
    public void A5Hash_LargeInputs_ProducesSameOutputAsNative(LargeTestVector vector)
    {
        var input = TestVectors.GenerateSequentialBytes(vector.Length);
        var hasher = new global::A5Hash.A5Hash(seed: 0);
        
        ulong actual = hasher.Hash(input);
        Assert.Equal(vector.ExpectedHash64, actual);
    }
    
    #endregion
    
    #region A5Hash32 (32-bit) Tests
    
    [Theory]
    [MemberData(nameof(GetTestVectors))]
    public void A5Hash32_ProducesSameOutputAsNative(TestVector vector)
    {
        var hasher = new global::A5Hash.A5Hash(vector.Seed64, vector.Seed32);
        uint actual = hasher.Hash32(vector.Input);
        Assert.Equal(vector.ExpectedHash32, actual);

        // Spot-check x4 API for fixed-size keys.
        global::A5Hash.A5Hash.Hash32x4(1u, 2u, 3u, 4u, out uint h0, out uint h1, out uint h2, out uint h3, seed: vector.Seed32);
        Assert.Equal(global::A5Hash.A5Hash.Hash32(1u, vector.Seed32), h0);
        Assert.Equal(global::A5Hash.A5Hash.Hash32(2u, vector.Seed32), h1);
        Assert.Equal(global::A5Hash.A5Hash.Hash32(3u, vector.Seed32), h2);
        Assert.Equal(global::A5Hash.A5Hash.Hash32(4u, vector.Seed32), h3);
    }
    
    [Theory]
    [MemberData(nameof(GetLargeTestVectors))]
    public void A5Hash32_LargeInputs_ProducesSameOutputAsNative(LargeTestVector vector)
    {
        var input = TestVectors.GenerateSequentialBytes(vector.Length);
        var hasher = new global::A5Hash.A5Hash(seed64: 0, seed32: 0);
        
        uint actual = hasher.Hash32(input);
        Assert.Equal(vector.ExpectedHash32, actual);
    }
    
    #endregion
    
    #region A5Hash128 (128-bit) Tests
    
    [Theory]
    [MemberData(nameof(GetTestVectors))]
    public void A5Hash128_ProducesSameOutputAsNative(TestVector vector)
    {
        var hasher = new global::A5Hash.A5Hash(vector.Seed64);
        var (low, high) = hasher.Hash128(vector.Input);
        Assert.Equal(vector.ExpectedHash128Low, low);
        Assert.Equal(vector.ExpectedHash128High, high);
    }
    
    [Theory]
    [MemberData(nameof(GetLargeTestVectors))]
    public void A5Hash128_LargeInputs_ProducesSameOutputAsNative(LargeTestVector vector)
    {
        var input = TestVectors.GenerateSequentialBytes(vector.Length);
        var hasher = new global::A5Hash.A5Hash(seed: 0);
        
        var (low, high) = hasher.Hash128(input);
        Assert.Equal(vector.ExpectedHash128Low, low);
        Assert.Equal(vector.ExpectedHash128High, high);
    }
    
    #endregion
    
    #region Test Data Providers
    
    public static IEnumerable<object[]> GetTestVectors()
    {
        foreach (var vector in TestVectors.Vectors)
        {
            yield return new object[] { vector };
        }
    }
    
    public static IEnumerable<object[]> GetLargeTestVectors()
    {
        foreach (var vector in TestVectors.LargeVectors)
        {
            yield return new object[] { vector };
        }
    }
    
    #endregion
}
